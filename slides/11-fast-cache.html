<!-- 12. INTRUSIVE POWER-OF-2 RANDOM CHOICE CACHE -->
<section id="fast-cache">
  <section class="section-header">
    <h2>Intrusive Power-of-2 Random Choice Cache</h2>
    <p>Map for lookups + intrusive Array for eviction</p>
  </section>

  <section>
    <h3>The Problems with LRU</h3>
    <ul class="spaced" style="font-size:0.75em">
      <li>
        <strong style="color:#ff5252">Cache pollution</strong> — a single access promotes an item to head of the LRU list.
        One-time reads and rare keys push out hot data.
      </li>
      <li>
        <strong style="color:#ff5252">Implementation overhead</strong> — doubly-linked list: every entry = <code>{key, value, prev, next}</code>.
        Every access = unlink + relink at head. Pointer chasing through scattered heap memory = CPU cache unfriendly. Every entry = wrapper allocation → GC pressure.
      </li>
      <li>
        <strong style="color:#ff5252">Scan problem</strong> — iterating a dataset larger than cache wipes the entire cache.
        Every item gets "most recently used" status. LRU degrades to 0% hit rate; random degrades gracefully.
      </li>
    </ul>
  </section>

  <section>
    <h3>Power-of-2 Random Choices</h3>
    <p style="font-size:0.8em;color:#ccc;margin-bottom:12px">Instead of maintaining strict ordering — pick 2 random entries, evict the older one</p>
    <div class="diagram-box" style="font-size:0.65em">
      <div class="diagram-row" style="gap:16px">
        <div class="diagram-cell good" style="border-color:#4ec9b0">
          <h4 style="color:#4ec9b0">Resists one-hit-wonders</h4>
          <p style="color:#bbb;margin:4px 0">A rarely accessed item must beat <strong style="color:#fff">both</strong> random picks to survive — statistically unlikely</p>
        </div>
        <div class="diagram-cell good" style="border-color:#4ec9b0">
          <h4 style="color:#4ec9b0">Scan resistant</h4>
          <p style="color:#bbb;margin:4px 0">Random picks spread across cache — scans can't systematically push out hot items</p>
        </div>
      </div>
      <div class="diagram-row" style="gap:16px;margin-top:12px">
        <div class="diagram-cell good" style="border-color:#4ec9b0">
          <h4 style="color:#4ec9b0">Near-LRU quality</h4>
          <p style="color:#bbb;margin:4px 0">2-random matches or beats LRU for larger caches <span style="color:#888">(danluu.com/2choices-eviction)</span></p>
        </div>
        <div class="diagram-cell good" style="border-color:#4ec9b0">
          <h4 style="color:#4ec9b0">Graceful degradation</h4>
          <p style="color:#bbb;margin:4px 0">Hit rate declines smoothly under pressure — unlike LRU which cliff-drops to 0%</p>
        </div>
      </div>
    </div>
    <div class="insight">
      No linked list, no wrapper nodes, no pointer chasing. Natural resistance to cache pollution.
    </div>
  </section>

  <section>
    <h3>Implementation — Structure</h3>
    <pre><code class="language-javascript">class FastCache {
  #map = new Map()    // key → item (O(1) lookup)
  #arr = []           // unordered items (O(1) swap-remove)
  #tick = 0           // monotonic counter for eviction policy
  #capacity

  constructor (capacity) {
    this.#capacity = capacity
  }

  get(key)
  set(key, item)
}</code></pre>
  </section>

  <section>
    <h3>Implementation — get()</h3>
    <pre><code class="language-javascript">  get(key) {
    const item = this.#map.get(key)
    if (item !== undefined) item[kCacheTick] = ++this.#tick
    return item
  }</code></pre>
  </section>

  <section>
    <h3>Implementation — set()</h3>
    <pre><code class="language-javascript">  set(key, item) {
    if (item[kCacheIdx] !== -1) { item[kCacheTick] = ++this.#tick; return }

    if (this.#arr.length >= this.#capacity) {
      const i = (Math.random() * this.#arr.length) | 0
      const j = (Math.random() * this.#arr.length) | 0
      const idx = this.#arr[i][kCacheTick] <= this.#arr[j][kCacheTick] ? i : j
      const evicted = this.#arr[idx]
      this.#map.delete(evicted[kCacheKey])
      const last = this.#arr.pop() // swap-remove
      if (last !== evicted) {
        this.#arr[idx] = last; last[kCacheIdx] = idx
      }
      evicted[kCacheIdx] = -1
    }
    item[kCacheKey] = key
    item[kCacheTick] = ++this.#tick
    item[kCacheIdx] = this.#arr.length
    this.#arr.push(item); this.#map.set(key, item)
  }</code></pre>
  </section>

  <section>
    <h3>Intrusive Random-2 vs LRU Cache</h3>
    <table class="benchmark">
      <thead><tr><th>Operation</th><th>Intrusive Random-2</th><th>lru-cache</th><th>Speedup</th></tr></thead>
      <tbody>
        <tr><td>get (hit)</td><td>14.6 ns</td><td>23.8 ns</td><td><strong>1.6x</strong></td></tr>
        <tr><td>set (warm)</td><td>8.1 ns</td><td>87 ns</td><td><strong>10.8x</strong></td></tr>
        <tr><td>mixed get/set 80/20</td><td>23.3 ns</td><td>34.2 ns</td><td><strong>1.5x</strong></td></tr>
        <tr><td>eviction (256 ops)</td><td>646 ns</td><td>33 µs</td><td><strong>51x</strong></td></tr>
        <tr><td>batch 1000</td><td>6.9 µs</td><td>101 µs</td><td><strong>14.7x</strong></td></tr>
        <tr><td>GC pressure (1000 ops)</td><td>~0 B</td><td>48.2 KB</td><td class="speedup">zero alloc</td></tr>
      </tbody>
    </table>
    <div class="insight">
      Intrusive bookkeeping + monotonic tick counter + swap-remove = zero-alloc cache.
    </div>
  </section>
</section>
