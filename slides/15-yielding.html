<!-- 8. YIELDING & EVENT LOOP LAG -->
<section id="yielding">
  <section class="section-header">
    <h2>Yielding &amp; Event Loop Lag</h2>
    <p><span class="npm-badge">@nxtedition/yield</span></p>
  </section>

  <section>
    <h3>The Problem: Event Loop Starvation</h3>
    <div class="diagram-box" style="padding:14px 18px">
      <div style="text-align:center;color:#e7ad52;font-weight:bold;font-size:0.85em;margin-bottom:10px">Event Loop Timeline</div>
      <!-- Before: healthy event loop -->
      <div style="font-size:0.65em;color:#888;margin-bottom:4px">Normal operation — short tasks interleaved:</div>
      <div style="display:flex;gap:2px;height:28px;border-radius:4px;overflow:hidden;margin-bottom:12px">
        <div style="flex:2;background:#4ec9b0;display:flex;align-items:center;justify-content:center;color:#111;font-weight:bold;font-size:0.65em">HTTP</div>
        <div style="flex:1;background:#569cd6;display:flex;align-items:center;justify-content:center;color:#111;font-weight:bold;font-size:0.65em">timer</div>
        <div style="flex:2;background:#c586c0;display:flex;align-items:center;justify-content:center;color:#111;font-weight:bold;font-size:0.65em">I/O cb</div>
        <div style="flex:1;background:#e7ad52;display:flex;align-items:center;justify-content:center;color:#111;font-weight:bold;font-size:0.65em">timer</div>
        <div style="flex:2;background:#4ec9b0;display:flex;align-items:center;justify-content:center;color:#111;font-weight:bold;font-size:0.65em">HTTP</div>
        <div style="flex:1;background:#569cd6;display:flex;align-items:center;justify-content:center;color:#111;font-weight:bold;font-size:0.65em">I/O</div>
      </div>
      <!-- Starvation: one long task blocks everything -->
      <div style="font-size:0.65em;color:#ff5252;margin-bottom:4px">Starvation — one long synchronous task blocks the loop:</div>
      <div style="display:flex;gap:2px;height:28px;border-radius:4px;overflow:hidden;margin-bottom:4px">
        <div style="flex:1;background:#4ec9b0;display:flex;align-items:center;justify-content:center;color:#111;font-weight:bold;font-size:0.65em">HTTP</div>
        <div style="flex:12;background:#ff5252;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:bold;font-size:0.75em">Your sync code: 200 ms</div>
        <div style="flex:1;background:#569cd6;display:flex;align-items:center;justify-content:center;color:#111;font-weight:bold;font-size:0.65em">I/O</div>
      </div>
      <div style="display:flex;gap:2px;height:16px;margin-bottom:6px">
        <div style="flex:1"></div>
        <div style="flex:12;display:flex;align-items:center;justify-content:center">
          <div style="font-size:0.6em;color:#ff5252">← HTTP requests, timers, I/O callbacks all waiting →</div>
        </div>
        <div style="flex:1"></div>
      </div>
    </div>
    <p>If your code runs for 200ms synchronously, <br>
      <strong>nothing else happens for 200ms</strong>.</p>
  </section>

  <section>
    <h3>Promise Chains Starve Too</h3>
    <pre><code class="language-javascript">// Each .then() runs as a microtask — microtasks drain BEFORE
// the event loop continues to timers, I/O, or new connections

async function processAll(items) {
  for (const item of items) {
    await transform(item)  // microtask after microtask after microtask...
  }
}
// 10,000 items = 10,000 microtasks back-to-back
// timers, I/O callbacks, HTTP requests — all starved until done</code></pre>
    <div class="insight">
      <code>await</code> doesn't yield to the event loop — it yields to the microtask queue.
      Microtasks run to exhaustion before the loop advances. Use <code>setImmediate</code> to truly yield.
    </div>
  </section>

  <section>
    <h3>Cooperative Yielding</h3>
    <pre><code class="language-javascript">import { maybeYield } from '@nxtedition/yield'

// Yield to the event loop if we've exceeded the time budget (40ms)
for (const row of db.prepare('SELECT * FROM huge_table').iterate()) {
  processRow(row)
  const yielded = maybeYield() // returns Promise or undefined
  if (yielded) {
    await yielded  // Give the event loop a turn
  }
}</code></pre>
  </section>

  <section>
    <h3>How It Works</h3>
    <pre><code class="language-javascript">// Tracks time since last yield using performance.now()
let yieldTime = performance.now()
let yieldTimeout = 40  // default — loosely based on keeping lag manageable

function shouldYield(timeout = yieldTimeout) {
  return performance.now() - yieldTime >= timeout
}

function maybeYield() {
  // return undefined or add to queue and batch drain with setImmediate
  return shouldYield() ? new Promise(doYield) : undefined
}</code></pre>
    <div class="insight">
      Yielding lets you use sync APIs (readFileSync, DatabaseSync) on the main thread
      without starving the event loop. Do real work, yield, repeat — best of both worlds.
    </div>
  </section>
</section>
