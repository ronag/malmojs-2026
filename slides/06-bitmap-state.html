<!-- BITMAP STATE -->
<section id="bitmap-state">
  <section class="section-header">
    <h2>Bitmap State</h2>
    <p>Pack flags and counters into a single integer</p>
  </section>

  <section>
    <h3>The Pattern</h3>
    <div style="display:flex;gap:16px">
      <div style="flex:1">
        <div style="font-size:0.65em;color:#ff5252;margin-bottom:6px">Object properties — scattered state</div>
        <pre><code class="language-javascript">class State {
  objectMode  = false
  ended       = false
  endEmitted  = false
  reading     = false
  flowing     = false
  paused      = false
  destroyed   = false
  // ... 21 more booleans
}
// Each property: separate heap slot
// State spread across multiple cache lines</code></pre>
      </div>
      <div style="flex:1">
        <div style="font-size:0.65em;color:#4ec9b0;margin-bottom:6px">Bitmap — all state in one integer</div>
        <pre><code class="language-javascript">const kObjectMode  = 1 << 0
const kEnded       = 1 << 1
const kEndEmitted  = 1 << 2
const kReading     = 1 << 3
const kFlowing     = 1 << 4
const kPaused      = 1 << 5
const kDestroyed   = 1 << 6

let state = 0              // one 31-bit integer
state |= kReading          // set
state &= ~kReading         // clear
state & kReading           // test</code></pre>
      </div>
    </div>
    <div class="insight">
      28 booleans → 4 bytes. State fits in a single CPU register.
      Testing multiple flags is a single bitwise AND — no branching, no pointer chasing.
    </div>
  </section>

  <section>
    <h3>Compound Tests — Free with Bitmasks</h3>
    <pre><code class="language-javascript">const kEnded      = 1 << 9
const kDestroyed  = 1 << 4
const kClosed     = 1 << 5
const kErrored    = 1 << 7

// Test any of N flags in one operation — no branching, no multiple loads
const kDone = kEnded | kDestroyed | kClosed | kErrored

if (state & kDone) return   // stream is finished in any terminal state

// Equivalent object version — 4 separate memory reads + 3 branches:
if (s.ended || s.destroyed || s.closed || s.errored) return</code></pre>
    <div class="insight">
      The CPU can evaluate <code>state & kDone</code> in a single instruction.
      The object version requires loading 4 separate fields — potentially 4 cache misses if the object is cold.
    </div>
  </section>

  <section>
    <h3>Counters in LSB</h3>
    <pre><code class="language-javascript">// Pack a small counter in the low bits, flags above it
//
//  bit 31 ──────────────── bit 8   bit 7 ─── bit 0
//  [ flags (1 bit each)         ]  [ counter (8 bits) ]
//
const kCounterMask = 0xFF          // bits 0–7 (max 255)
const kFlag        = 1 << 8        // first flag above counter

let state = 0

state++              // increment counter directly — no shift needed
state--              // decrement
state & kCounterMask // read counter
state & kFlag        // test flag — unaffected by counter arithmetic</code></pre>
    <div class="insight">
      Placing a counter in the LSBs lets you use <code>++</code>/<code>--</code> directly on the integer
      without masking. Reference counts, queue depths, pending I/O counts — all free to pack in.
    </div>
  </section>

  <section>
    <h3>Benchmarks</h3>
    <table class="benchmark">
      <thead><tr><th>Operation</th><th>Object</th><th>Bitmap</th><th>Δ</th></tr></thead>
      <tbody>
        <tr>
          <td>test 31 flags (any set?)</td>
          <td>2.10 ns</td>
          <td class="speedup">234 ps</td>
          <td style="color:#4ec9b0">Bitmap <strong>9.0×</strong></td>
        </tr>
        <tr>
          <td>update 31 flags (bulk reset)</td>
          <td>2.43 ns</td>
          <td class="speedup">267 ps</td>
          <td style="color:#4ec9b0">Bitmap <strong>9.1×</strong></td>
        </tr>
        <tr>
          <td>scan 64K objects (cache-cold)</td>
          <td>563 µs</td>
          <td class="speedup">23.9 µs</td>
          <td style="color:#4ec9b0">Bitmap <strong>23.6×</strong></td>
        </tr>
      </tbody>
    </table>
    <div class="insight">
      The real win is density. 64K bitmaps = 256 KB — fits in L2.
      64K objects = 9.5 MB — spills to L3/RAM. Cache misses dominate: <strong>23.6×</strong> slower scan.
      Fewer bytes per state = more states per cache line = fewer misses at scale.
    </div>
  </section>

  <section>
    <h3>Real World: Node.js Streams</h3>
    <pre><code class="language-javascript">// lib/internal/streams/utils.js — shared across all stream types
const kObjectMode  = 1 << 0   // bits 0–8: common to Readable, Writable, Duplex
const kErrorEmitted = 1 << 1
const kAutoDestroy  = 1 << 2
const kDestroyed    = 1 << 4
const kErrored      = 1 << 7
const kConstructed  = 1 << 8

// lib/internal/streams/readable.js — Readable-specific, start at bit 9
const kEnded             = 1 << 9
const kReading           = 1 << 11
const kNeedReadable      = 1 << 13
const kReadableListening = 1 << 15
const kFlowing           = 1 << 24
const kDataListening     = 1 << 27</code></pre>
    <div class="insight">
      28 stream flags — Readable + Writable + shared — packed into a single <code>kState</code> integer per stream instance.
    </div>
  </section>
</section>
