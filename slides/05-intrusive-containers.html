<!-- 11. INTRUSIVE CONTAINERS -->
<section id="intrusive-containers">
  <section class="section-header">
    <h2>Intrusive Containers</h2>
  </section>

  <section>
    <h3>Standard vs Intrusive O(1) Removal</h3>
    <div class="columns">
      <div class="col">
        <h4>Standard (allocating)</h4>
        <pre><code class="language-javascript">// Set/Map creates internal nodes
const set = new Set()
set.add(item) // Internal node allocated
set.delete(item) // Node deallocated → GC

// LinkedList creates internal nodes
const list = new LinkedList()
list.add(item) // Internal node allocated
list.remove(item) // Internal node deallocated → GC

// Array with splice
const arr = []
arr.push(item) // No allocation (amortized)
// Remove from middle:
arr.splice(idx, 1) // O(n) shift!</code></pre>
</code></pre>
      </div>
      <div class="col">
        <h4>Intrusive (zero allocations)</h4>
        <pre><code class="language-javascript">// Item stores its own index
function add(arr, item) {
  item[kIndex] = arr.length
  arr.push(item)
}
function remove(arr, item) {
  // O(1) swap-remove
  const idx = item[kIndex]
  const last = arr.pop()
  if (last !== item) {
    arr[idx] = last
    last[kIndex] = idx
  }
  item[kIndex] = -1
}</code></pre>
      </div>
    </div>
  </section>

  <section>
    <h3>O(1) Swap-Remove</h3>
    <div class="diagram-box" style="font-size:0.6em">
      <div style="margin-bottom:12px">
        <div style="color:#ff5252;font-weight:bold;margin-bottom:6px">Traditional splice: O(n)</div>
        <div style="display:flex;gap:3px;align-items:center;margin-bottom:4px">
          <span class="swap-cell">A</span><span class="swap-cell">B</span><span class="swap-cell swap-target">C</span><span class="swap-cell">D</span><span class="swap-cell">E</span>
          <span style="color:#999;margin:0 8px">→ remove C →</span>
          <span class="swap-cell">A</span><span class="swap-cell">B</span><span class="swap-cell swap-empty">_</span><span class="swap-cell">D</span><span class="swap-cell">E</span>
          <span style="color:#999;margin:0 8px">→ shift →</span>
          <span class="swap-cell">A</span><span class="swap-cell">B</span><span class="swap-cell swap-moved">D</span><span class="swap-cell swap-moved">E</span>
        </div>
        <div style="color:#ff5252;font-size:0.9em;padding-left:4px">Every element after C must shift left, O(n)</div>
      </div>
      <div class="separator"></div>
      <div>
        <div style="color:#4ec9b0;font-weight:bold;margin-bottom:6px">Swap-remove: O(1)</div>
        <div style="display:flex;gap:3px;align-items:center;margin-bottom:4px">
          <span class="swap-cell">A</span><span class="swap-cell">B</span><span class="swap-cell swap-target">C</span><span class="swap-cell">D</span><span class="swap-cell">E</span>
          <span style="color:#999;margin:0 8px">→ swap C↔E →</span>
          <span class="swap-cell">A</span><span class="swap-cell">B</span><span class="swap-cell swap-moved">E</span><span class="swap-cell">D</span>
        </div>
        <div style="color:#4ec9b0;font-size:0.9em;padding-left:4px">Only 1 move + pop, O(1). Order doesn't matter? Use swap-remove.</div>
      </div>
    </div>
    <div class="insight">
      Intrusive containers embed bookkeeping in the item itself.
      No wrapper nodes = zero GC overhead. Combined with swap-remove = O(1) add AND remove.
    </div>
  </section>

  <section>
    <h3>Standard vs Intrusive Containers</h3>
    <div style="font-size:0.7em;color:#999;margin-bottom:8px;text-align:center">
      remove + re-add on pre-filled container (N=10,000)
    </div>
    <table class="benchmark">
      <thead>
        <tr><th>Container</th><th>Time</th><th>GC pressure</th><th>vs Intrusive</th></tr>
      </thead>
      <tbody>
        <tr>
          <td>Intrusive Array (swap)</td>
          <td class="speedup">~5 ns</td>
          <td class="speedup">~0 B</td>
          <td>baseline</td>
        </tr>
        <tr>
          <td>Intrusive Linked List</td>
          <td>~14 ns</td>
          <td class="speedup">~0 B</td>
          <td>2.7x slower</td>
        </tr>
        <tr>
          <td>Array (splice)</td>
          <td>~1.75 µs</td>
          <td>~25 B</td>
          <td style="color:#ff5252">350x slower</td>
        </tr>
        <tr>
          <td>Linked List</td>
          <td>~30 µs</td>
          <td>~100 B</td>
          <td style="color:#ff5252">5,800x slower</td>
        </tr>
      </tbody>
    </table>
    <p class="small">Apple M3 Pro / Node.js 25.3.0</p>
    <div class="insight">
      Intrusive swap-remove is O(1), ~5ns regardless of container size.
      At N=10,000: array splice is <strong>350x slower</strong>, linked list is <strong>5,800x slower</strong> (node allocation + pointer chasing + GC).
    </div>
  </section>

</section>
