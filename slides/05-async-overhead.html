<!-- 4. OVERHEAD OF ASYNC/AWAIT & PROMISES -->
<section id="async-overhead">
  <section class="section-header">
    <h2>Overhead of async/await &amp; Promises</h2>
    <p>Convenience has a cost</p>
  </section>

  <section>
    <h3>What async/await Actually Does</h3>
    <pre><code class="language-javascript">// This innocent-looking code:
async function getUser(id) {
  const user = await db.findById(id)
  return user
}

// Creates under the hood:
// 1. A Promise object
// 2. A microtask for resolution
// 3. Captures the async context (AsyncLocalStorage, etc.)
// 4. Suspends and resumes the function execution
// 5. Another microtask for the awaited promise</code></pre>
    <div class="insight">
      Each <code>await</code> creates at minimum 1 Promise + 1-2 microtask queue entries.
      On hot paths running millions of times, this adds up fast.
    </div>
  </section>

  <section>
    <h3>The Cost Chain</h3>
    <pre><code class="language-javascript">// Every layer of async adds overhead
async function getUser(id) {             // Promise #1
  const row = await queryDb(id)          // Promise #2
  return formatUser(row)
}

async function queryDb(id) {             // Promise #3
  const conn = await pool.acquire()      // Promise #4
  try {
    return await conn.query('...', [id]) // Promise #5
  } finally {
    pool.release(conn)
  }
}

// One "simple" DB query = 5+ Promises allocated
// At 10,000 req/s = 50,000 Promises/s = GC pressure</code></pre>
  </section>

  <section>
    <h3>Callback vs async/await</h3>
    <table class="benchmark">
      <thead>
        <tr><th>Pattern</th><th>Time</th><th>vs callback</th></tr>
      </thead>
      <tbody>
        <tr>
          <td>sync function</td>
          <td>1.0 ns</td>
          <td class="speedup">baseline</td>
        </tr>
        <tr>
          <td>callback (sync fire)</td>
          <td>2.3 ns</td>
          <td class="speedup">~1x</td>
        </tr>
        <tr>
          <td>async/await</td>
          <td>338 ns</td>
          <td><strong>145x slower</strong></td>
        </tr>
        <tr>
          <td>new Promise(resolve => ...)</td>
          <td>311 ns</td>
          <td><strong>133x slower</strong></td>
        </tr>
      </tbody>
    </table>
    <p class="small">Apple M3 Pro / Node.js 25.3.0 — .gc('inner') enabled</p>
    <div class="insight">
      Callbacks fire synchronously with zero allocation. <code>async/await</code> always creates
      a Promise + microtask — even when the result is already available.
    </div>
  </section>

  <section>
    <h3>Sync Fast Path</h3>
    <pre><code class="language-javascript">// If the value is already available, avoid async entirely
function getFromCache(id) {
  const cached = cache.get(id)
  if (cached !== undefined) {
    return cached  // No Promise, no microtask, instant
  }
  // Only go async when actually needed
  return getFromCacheAsync(id)
}

async function getFromCacheAsync(id) {
  const value = await db.get(id)
  cache.set(id, value)
  return value
}</code></pre>
    <div class="insight">
      Split your hot paths into sync and async variants.
      When the common case is synchronous (cache hit), you skip all async overhead.
    </div>
  </section>
</section>
