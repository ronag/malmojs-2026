<!-- 7. FAST TIME & TIMERS -->
<section id="fast-timers">
  <section class="section-header">
    <h2>Fast Time &amp; Timers</h2>
    <p><span class="npm-badge">@nxtedition/timers</span></p>
  </section>

  <section>
    <h3>Fast Time: Cached Timestamps</h3>
    <pre><code class="language-javascript">let fastNow = Date.now()
let fastISO = new Date().toISOString()

setInterval(() => {
  fastNow = Date.now()
  fastISO = new Date().toISOString()
}, 1e3).unref()

// Hot path: use fastNow/fastISO instead of Date.now()
// 1-second resolution is fine for logging, HTTP headers, timeouts, etc.</code></pre>
    <table class="benchmark" style="margin-top:10px">
      <thead>
        <tr><th>Operation</th><th>Native</th><th>Cached</th><th>Speedup</th></tr>
      </thead>
      <tbody>
        <tr>
          <td>Date.now()</td>
          <td>34 ns</td>
          <td>0.5 ns</td>
          <td class="speedup">64x</td>
        </tr>
        <tr>
          <td>new Date().toISOString()</td>
          <td>625 ns</td>
          <td>0.5 ns</td>
          <td class="speedup">1,239x</td>
        </tr>
      </tbody>
    </table>
    <p class="small">Apple M3 Pro / Node.js 25.3.0</p>
    <div class="insight">
      On hot paths, reading a cached variable is a plain memory load -
      no syscall, no allocation, no string formatting.
    </div>
  </section>

  <section>
    <h3>Why Native Timers are "Expensive"</h3>
    <p style="font-size:0.75em;color:#ccc;margin-bottom:10px">Each <code style="color:#e7ad52">setTimeout</code> creates a C++ TimerWrap object</p>
    <!-- What each timer allocates -->
    <div style="display:flex;gap:10px;margin-bottom:12px">
      <div style="flex:1;background:#1a1a1a;border-radius:6px;padding:10px 14px;border-left:3px solid #ff5252">
        <div style="color:#ff5252;font-weight:bold;font-size:0.8em;margin-bottom:4px">libuv timer handle</div>
        <div style="color:#999;font-size:0.7em">OS resource allocation per timer</div>
      </div>
      <div style="flex:1;background:#1a1a1a;border-radius:6px;padding:10px 14px;border-left:3px solid #ff5252">
        <div style="color:#ff5252;font-weight:bold;font-size:0.8em;margin-bottom:4px">V8 weak reference</div>
        <div style="color:#999;font-size:0.7em">Registered in weak ref table</div>
      </div>
      <div style="flex:1;background:#1a1a1a;border-radius:6px;padding:10px 14px;border-left:3px solid #ff5252">
        <div style="color:#ff5252;font-weight:bold;font-size:0.8em;margin-bottom:4px">GC traced every cycle</div>
        <div style="color:#999;font-size:0.7em">C++ handle must be walked</div>
      </div>
      <div style="flex:1;background:#1a1a1a;border-radius:6px;padding:10px 14px;border-left:3px solid #ff5252">
        <div style="color:#ff5252;font-weight:bold;font-size:0.8em;margin-bottom:4px">Cleanup on fire/clear</div>
        <div style="color:#999;font-size:0.7em">C++ destructor + deregistration</div>
      </div>
    </div>
    <!-- Scale impact -->
    <div class="diagram-box" style="padding:12px 16px;border-color:#e7ad52">
      <div style="display:flex;align-items:center;justify-content:center;gap:16px;font-size:0.9em">
        <div style="text-align:center">
          <div style="color:#e7ad52;font-weight:bold;font-size:1.4em">10,000</div>
          <div style="color:#999;font-size:0.85em">concurrent connections</div>
        </div>
        <div style="color:#666;font-size:1.4em">&times;</div>
        <div style="text-align:center">
          <div style="color:#e7ad52;font-weight:bold;font-size:1.4em">1</div>
          <div style="color:#999;font-size:0.85em">idle timeout each</div>
        </div>
        <div style="color:#666;font-size:1.4em">=</div>
        <div style="text-align:center">
          <div style="color:#ff5252;font-weight:bold;font-size:1.4em">10,000</div>
          <div style="color:#999;font-size:0.85em">C++ objects for GC to trace <strong style="color:#ff5252">every cycle</strong></div>
        </div>
      </div>
    </div>
  </section>

  <section>
    <h3>Pooled Timers: The Solution</h3>
    <pre><code class="language-javascript">import { setTimeout, clearTimeout } from '@nxtedition/timers'

// For delays >= 1000ms: uses a SINGLE shared timer
// that fires every 500ms and checks all pending timers
const handle = setTimeout((ctx) => console.log('hello'), 5000)

// For delays < 1000ms: falls through to native setTimeout
// (full resolution needed for short timers)
const fast = setTimeout(() => console.log('hello'), 50)

// clearTimeout works for both
clearTimeout(handle)
clearTimeout(fast)</code></pre>
  </section>

  <section>
    <h3>How It Works Internally</h3>
    <pre><code class="language-javascript">// ONE shared timer fires every 500ms
let fastNow = 0; let fastIdx = 0; const fastTimers = []
function onTimeout() {
  fastNow += 500
  dispatch()
}
function dispatch() {
  while (fastIdx < fastTimers.length) {
    const timer = fastTimers[fastIdx]
    if (timer.state < fastNow) {
      timer.state = -1                // mark as fired
      timer.callback(timer.opaque)    // opaque, not closure!
      swapRemove(fastTimers, fastIdx) // swap-remove O(1)
    } else if ((++fastIdx & 0xff) === 0 && shouldYield()) {
      doYield(dispatch) // maybe yield to event loop every 256 timers. More about this later...
      return
    }
  }
  fastIdx = 0
}</code></pre>
  </section>

  <section>
    <h3>Native vs Pooled setTimeout</h3>
    <table class="benchmark">
      <thead>
        <tr><th>Operation</th><th>Native setTimeout</th><th>Pooled setTimeout</th><th>Speedup</th></tr>
      </thead>
      <tbody>
        <tr>
          <td>create + clear</td>
          <td>250.91 ns</td>
          <td>58.90 ns</td>
          <td class="speedup">4.3x</td>
        </tr>
        <tr>
          <td>create + clear (GC)</td>
          <td>1.95 &micro;s</td>
          <td>73.99 ns</td>
          <td class="speedup">26.4x</td>
        </tr>
        <tr>
          <td>batch create+clear 100x (GC)</td>
          <td>41.84 &micro;s</td>
          <td>9.80 &micro;s</td>
          <td class="speedup">4.3x</td>
        </tr>
      </tbody>
    </table>
    <p class="small">Apple M3 Pro / Node.js 25.3.0</p>
    <div class="insight">
      Under GC pressure the advantage is <strong>26x</strong>.
      Native timer handles are expensive C++ objects for the GC to trace.
      Pooled timers are plain JS objects, invisible to the C++ GC.
    </div>
  </section>
</section>
